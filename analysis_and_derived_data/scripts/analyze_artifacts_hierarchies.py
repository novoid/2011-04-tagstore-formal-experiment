#!/usr/bin/env python
# -*- coding: utf-8 -*-
## auto last change for vim and Emacs: (whatever comes last)
## Latest change: Mon Mar 08 11:49:34 CET 2010
## Time-stamp: <2012-04-25 13:56:14 vk>
"""
analyze_artifacts_hierarchies.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:copyright: (c) 2012 by Karl Voit <Karl.Voit@IST.TUGraz.at>
:license: GPL v2 or any later version
:bugreports: <Karl.Voit@IST.TUGraz.at>

See USAGE below for details!

FIXXME:
    * look for the string FIXXME to improve this script

"""

import logging    # logging
import sys        # flushing stdout
import os         # accessing file system
import ntpath     # manipulating Windows specific path strings
from optparse import OptionParser  # parsing command line options
import re         # RegEx
import codecs     # fixing UTF-8 issues

## debugging:   for setting a breakpoint:  pdb.set_trace()
import pdb

## ======================================================================= ##
##                                                                         ##
##         You should NOT need to modify anything below this line!         ##
##                                                                         ##
## ======================================================================= ##


USAGE = "\n\
         %prog -i items.csv -t tpdata.log\n\
\n\
This script reads in one files containing a list of absolute paths to\n\
folders and files like this:  (generated by: dir /B /S)\n\
C:\\FE-data\\tp-data\\TP_T10\\Ordner\\Formulare\n\
C:\\FE-data\\tp-data\\TP_T10\\Ordner\\Formulare\\Antrag Familienbeihilfe.pdf\n\
C:\\FE-data\\tp-data\\TP_T10\\Ordner\\Formulare\\Arbeitszeugnis.jpg\n\
\n\
From these lines, TP number (here: 10), common path components\n\
(here: \"C:\\FE-data\\tp-data\\TP_T\" and \"\\Ordner\") and the\n\
rest is separated. The rest is classified as a test file (an element\n\
of items.csv) or a folder.\n\
\n\
Please do not add other digits in the path besides the IDs of the TPs.\n\
Please do pre-filtering tpdata.log so that it contains only lines\n\
related to hierarchy condition (and not tagstore condition as well).\n\
\n\
  :URL:        https://github.com/novoid/2011-04-tagstore-formal-experiment\n\
  :copyright:  (c) 2012 by Karl Voit <Karl.Voit@IST.TUGraz.at>\n\
  :license:    GPL v2 or any later version\n\
  :bugreports: <Karl.Voit@IST.TUGraz.at>\n\
\n\
Run %prog --help for usage hints\n"

parser = OptionParser(usage=USAGE)

parser.add_option("-i", "--itemfile", dest="itemfile",
                  help="CSV file of test items in format <NUMBER>, <NAME>", metavar="FILE")

parser.add_option("-t", "--tpfile", dest="tpfile",
                  help="file containing a listing of the hierarchy artifacts of the TPs", metavar="FILE")

parser.add_option("-v", "--verbose", dest="verbose", action="store_true",
                  help="enable verbose mode")

parser.add_option("-q", "--quiet", dest="quiet", action="store_true",
                  help="do not output anything but just errors on console")


(options, args) = parser.parse_args()


class vk_FileNotFoundException(Exception):

    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


def handle_logging():
    """Log handling and configuration"""

    if options.verbose:
        FORMAT = "%(levelname)-8s %(asctime)-15s %(message)s"
        logging.basicConfig(level=logging.DEBUG, format=FORMAT)
    elif options.quiet:
        FORMAT = "%(levelname)-8s %(message)s"
        logging.basicConfig(level=logging.CRITICAL, format=FORMAT)
    else:
        FORMAT = "%(message)s"
        logging.basicConfig(level=logging.INFO, format=FORMAT)


def error_exit(errorcode, text):
    """exits with return value of errorcode and prints to stderr"""

    sys.stdout.flush()
    logging.error(text + "\n")
    sys.exit(errorcode)


def extract_all_digits_of_string(string):
    """parses a string for occurrence of a number"""

    ## replacing all non-digits from the string and converting it to a integer
    digits = re.sub("\D", "", string)

    if not digits:
        error_exit(5, "ERROR: string \"" + string + "\" contains no digit which " + \
                       "could lead to a TP number.\nPlease keep TP numbers in folder names.")

    return int(digits)


def read_item_file(filename):
    """read in CSV file containing the test items and return a dict with itemname->number"""

    items = {}

    for line in codecs.open(filename, 'r', "utf-8"):
        content = line.strip().split(',')
        items[content[1]] = int(content[0])

    return items


def read_tpitems_from_file(filename):
    """read TP items from file which contains absolute Windows paths to all items"""

    allitems = []

    for line in codecs.open(filename, 'r', "latin1"):
        allitems.append(line.strip())

    return allitems


def remove_commonpath_from_items(allitems):
    """remove common path strings from all items in list"""

    commonpath = ntpath.commonprefix(allitems)
    logging.debug("common path: [%s]" % commonpath)

    allitems = [item[len(commonpath):] for item in allitems]

    return allitems


def guess_and_extract_tp_number(item):
    """takes a string like foo10\\bar\\item and extracts TP number 10 and returns array of number and rest of string"""

    #logging.debug("extracting TPnum from [%s]" % item)

    startfolder = item.split('\\')[0]

    rest = item[len(startfolder) + 1:]

    TPnum = extract_all_digits_of_string(startfolder)

    #logging.debug("extracted TPnum [%s] and rest [%s] from [%s]" % (TPnum, rest, item))

    return [TPnum, rest]


def split_items_into_TPnum_and_path(allitems):
    """split array of items into array of arrays with TP number and rest of path"""

    allitems = [guess_and_extract_tp_number(item) for item in allitems]

    return allitems


def remove_entries_with_empty_second_component(allitems):
    """scans an array and removes all entries where the second component is empty"""

    newitemarray = []

    for entry in allitems:
        if entry[1] != u'':
            newitemarray.append(entry)
        else:
            pass
            #logging.debug("dropping entry [%s] because of empty data" % str(entry))

    return newitemarray


def remove_commonpath_from_second_component(allitems):
    """scans through array and determines common path components in second component"""

    allpaths = []
    newitems = []

    for item in allitems:
        allpaths.append(item[1])

    shortenedpaths = remove_commonpath_from_items(allpaths)

    for counter in range(len(allitems)):
        newitems.append([allitems[counter][0], shortenedpaths[counter]])

    return newitems


def extract_array_of_TPnum_and_items(allitems):
    """takes an array of raw lines of TP folder data and creates array of TPnum and items"""

    ## allitems[15] == u'C:\\Tagstore_Usabillity_Test\\Ergebnisse\\tp-data-backup\\TP_T3\\Ordner\\Fun\\Zigaretten sind toedlich.jpg'

    allitems = remove_commonpath_from_items(allitems)

    ## allitems[15] == u'3\\Ordner\\Fun\\Zigaretten sind toedlich.jpg'

    allitems = split_items_into_TPnum_and_path(allitems)

    ## allitems[15] == [3, u'Ordner\\Fun\\Zigaretten sind toedlich.jpg']

    ## removing empty elements that appear because common component was only content:
    allitems = remove_entries_with_empty_second_component(allitems)

    ## allitems[15] == [3, u'Ordner\\Sport\\aktiv\\Marathon 2009.jpg']

    allitems = remove_commonpath_from_second_component(allitems)

    ## allitems[15] == [3, u'\\Sport\\aktiv\\Marathon 2009.jpg']

    ## removing empty elements that appear because common component was only content:
    allitems = remove_entries_with_empty_second_component(allitems)

    return allitems


def traverse_dataset(allitems, testitems):
    """walks through the TP data and derives statistical data"""

    for item in allitems:
        if ntpath.basename(item[1]) in testitems:
            logging.debug("TP %s: item [%s] is a file with ID %s" % (str(item[0]), item[1], testitems[ntpath.basename(item[1])]))
        else:
            logging.debug("TP %s: item [%s] is a folder" % (str(item[0]), item[1]))


def main():
    """Main function [make pylint happy :)]"""

    print "                analyze_artifacts_hierarchy.py\n"
    print "          (c) 2012 by Karl Voit <Karl.Voit@IST.TUGraz.at>"
    print "              GPL v2 or any later version\n"

    handle_logging()

    if not options.itemfile:
        error_exit(1, "ERROR: please give me one item-CSV-file.")

    if not os.path.isfile(options.itemfile):
        error_exit(2, "ERROR: item-CSV-file \"" + options.itemfile + "\" is not an existing file.")

    if not options.tpfile:
        error_exit(3, "ERROR: please give me one artifact-file.")

    if not os.path.isfile(options.tpfile):
        error_exit(4, "ERROR: artifact-file \"" + options.tpfile + "\" is not an existing file.")

    testitems = read_item_file(options.itemfile)

    allitems = extract_array_of_TPnum_and_items(read_tpitems_from_file(options.tpfile))

    ## allitems[15] == [3, u'\\Sport\\aktiv\\Marathon 2009.jpg']

    traverse_dataset(allitems, testitems)

    logging.info("finished.")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logging.info("Received KeyboardInterrupt")

## END OF FILE #################################################################
# vim:foldmethod=indent expandtab ai ft=python tw=120 fileencoding=utf-8 shiftwidth=4
